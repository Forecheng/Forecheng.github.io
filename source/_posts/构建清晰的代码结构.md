---
title: 构建清晰的代码结构总结
tags:
  - Android
  - 代码结构
toc: true
date: 2016-11-22 20:28:28
categories: 学习总结
---

### 项目结构
在创建新的项目初期，一般都会采用`MVP`模式对项目进行构建，现在很流行这种形式，为了使项目的结构清晰，在别人阅读代码时一目了然，使代码的结构更整洁，会对代码文件进行分类或分模块，让相关的代码文件放入其中，找相应代码文件的时候也更迅速，层次更加分明。如图：
<!--more-->
<div align=center>
![运行结果](/images/项目结构.png)
</div>

各个目录的意义：

 - adapter：存放适配器类
 - model：mvp的m层，用于提供数据，存放实体类、数据库相关类文件
 - presenter：mvp的p层，负责逻辑处理，连接view和model，并按照功能建立子目录进行细分
 - service：存放app中的服务类
 - taskapi：存放异步任务类或者mobileApi类
 - utils：工具类目录，比如获取app信息工具类，日志工具类，Toast工具类等
 - view：mvp中的v层，存放界面类，就是一些Activity和Fragment，并按照模块建立子目录进行细分，也包含自己定义的组件类
 - 其他：其他类文件

这样细分是为了保证一个文件就是一个单独的类，不含有嵌套类。
将Activity按照模块进行拆分后，可以迅速定位到一个界面，也有利于团队合作，边界清晰。
同时为每个任务定义监听器，回调任务执行完成后的结果

在进行接口或者监听器命名时，应该规范化：
```java
//接口以大写字母`I`开头
public interface IBaseView{

}

//监听器命名以`On`开头，用于任务结果的回调，比如登录：
public interface OnLoginListener{
	void loginSuccess();
    void loginFailed(String errorMsg);
}
```

### Application
尽可能为每个应用定制自己的`Application`类 ,方便在应用启动时进行一些数据的初始化，并拿到应用全局的上下文，并在其中对应用的Activity进行管理，而且在使用一些第三方库的时候，在Application类中进行初始化是最好的方式。
```java
/**
 * Description:
 * Created by L02465 on 2016.11.22.
 */
public class MleApp extends Application {

    private List<Activity> activities = new ArrayList<>();

    private static MleApp instance;

    @Override
    public void onCreate() {
        super.onCreate();
        instance = this;

    }

    public static MleApp getInstance(){
        return instance;
    }

    //新建一个activity
    public void addActivity(Activity activity){
        activities.add(activity);
    }

    //结束指定的activity
    public void finishActivity(Activity activity){
        if (activity != null){
            activities.remove(activity);
            activity.finish();
            activity = null;
        }
    }

    //exit app
    public void exitApp(){
        for (Activity activity:activities){
            if (activity != null){
                activity.finish();
            }
        }

        System.exit(0);
    }
}

```
记得在清单文件`AndroidManifest.xml`中调用：
```xml
<application
        android:name=".MleApp"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        ...
```
有了这个类，可以很方便的在应用的任何地方都可以拿到上下文。
### BaseActivity和BaseFragment
编写应用时，Activity是必不可少的，它是处理界面组件并呈现给用户的主体，我们以前使用的`MVC`模式渐渐被`MVP`所替代，主要原因就是项目复杂时，Activity中需要处理太多的逻辑，导致单个Activity文件很臃肿，而使用`MVP`可以缓解这种问题。在编写Activity时，需要厘清代码结构，尤其是在`onCreate()`中，一般处理以下几件事情：

 - 加载界面布局并初始化组件
 - 初始化数据
 - 为组件设置动作监听
 - 逻辑处理

为此，可以编写一个抽象的`BaseActivity`类，继承于`android.app.Activity`，在其中定义抽象方法，让其他的Activity继承于BaseActivity，并实现抽象方法即可，这样onCreate()代码就清晰了。
如下：
```java
/**
 * Description: BaseActivity
 * Created by L02465 on 2016.11.22.
 */
public abstract class BaseActivity extends Activity implements IBaseView{

    private ProgressDialog mProgressDialog;   //全局的加载Dialog

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        initView();
        initData();
        MleApp.getInstance().addActivity(this);      //将每个Activity加入到List中
    }

    public void initView(){
        loadViewLayout();
        findViewById();
        setListener();
    }

    public void initData(){
        initVariables();
        processLogic();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        MleApp.getInstance().finishActivity(this);
        if (mProgressDialog != null){
            mProgressDialog.dismiss();
        }
    }

    //实现IBaseView方法
    @Override
    public void showMsgDialog(String message) {
        if (mProgressDialog == null){
            mProgressDialog = ProgressDialog.show(this,null,message);
            mProgressDialog.setCancelable(false);
        }else{
            mProgressDialog.setMessage(message);
            mProgressDialog.show();
        }
    }

    @Override
    public void showResDialog(int resId) {
        if (mProgressDialog == null){
            mProgressDialog = ProgressDialog.show(this,null,getResources().getString(resId));
            mProgressDialog.setCancelable(false);
        }else{
            mProgressDialog.show();
        }
    }

    @Override
    public void hideDialog() {
        if (mProgressDialog != null){
            mProgressDialog.hide();
        }
    }

    //加载布局
    protected abstract void loadViewLayout();
    //加载页面组件
    protected abstract void findViewById();
    //事件监听器
    protected abstract void setListener();
    //初始化变量
    protected abstract void initVariables();
    //处理逻辑
    protected abstract void processLogic();

}
```
当然也有`BaseFragment`：
```java
/**
 1. Description:
 2. Created by L02465 on 2016.11.22.
 */
public abstract class BaseFragment extends Fragment {

    private View mView;

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        mView = initView(inflater,container,savedInstanceState);
        return mView;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
    }


    protected abstract View initView(LayoutInflater inflater,ViewGroup container,Bundle bundle);

    protected abstract void setListener();
    protected abstract void initDatas();
}
```
### 组件绑定事件
在组件绑定事件时，有几种方法：

 1. 类直接实现相应动作接口
 2. 类中写内部类实现动作接口  
 3. 为组件直接绑定动作接口

我认为第三种方法比较好，因为在组件较多的页面中，进行走读代码时，想知道组件干了什么事，首先要做的就是找到这个组件，并查看它的绑定事件，使用第三种方法，找到组件时就直接看到它的绑定事件，不像1、2种方法还需要在别处找相应代码，影响效率，而且第三种方法直接在组件上绑定事件，是面向对象的写法，在事件的处理中，尽可能封装成一个个方法，而不要使其显得过于臃肿。

**时时刻刻预防空指针异常是很必要的** >>>>>  ~~NullPointerException~~

