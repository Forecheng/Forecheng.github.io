<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[构建清晰的代码结构总结]]></title>
      <url>%2F2016%2F11%2F22%2F%E6%9E%84%E5%BB%BA%E6%B8%85%E6%99%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[项目结构在创建新的项目初期，一般都会采用MVP模式对项目进行构建，现在很流行这种形式，为了使项目的结构清晰，在别人阅读代码时一目了然，使代码的结构更整洁，会对代码文件进行分类或分模块，让相关的代码文件放入其中，找相应代码文件的时候也更迅速，层次更加分明。如图： 各个目录的意义： adapter：存放适配器类 model：mvp的m层，用于提供数据，存放实体类、数据库相关类文件 presenter：mvp的p层，负责逻辑处理，连接view和model，并按照功能建立子目录进行细分 service：存放app中的服务类 taskapi：存放异步任务类或者mobileApi类 utils：工具类目录，比如获取app信息工具类，日志工具类，Toast工具类等 view：mvp中的v层，存放界面类，就是一些Activity和Fragment，并按照模块建立子目录进行细分，也包含自己定义的组件类 其他：其他类文件 这样细分是为了保证一个文件就是一个单独的类，不含有嵌套类。将Activity按照模块进行拆分后，可以迅速定位到一个界面，也有利于团队合作，边界清晰。同时为每个任务定义监听器，回调任务执行完成后的结果 在进行接口或者监听器命名时，应该规范化：12345678910//接口以大写字母`I`开头public interface IBaseView&#123;&#125;//监听器命名以`On`开头，用于任务结果的回调，比如登录：public interface OnLoginListener&#123; void loginSuccess(); void loginFailed(String errorMsg);&#125; Application尽可能为每个应用定制自己的Application类 ,方便在应用启动时进行一些数据的初始化，并拿到应用全局的上下文，并在其中对应用的Activity进行管理，而且在使用一些第三方库的时候，在Application类中进行初始化是最好的方式。12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Description: * Created by L02465 on 2016.11.22. */public class MleApp extends Application &#123; private List&lt;Activity&gt; activities = new ArrayList&lt;&gt;(); private static MleApp instance; @Override public void onCreate() &#123; super.onCreate(); instance = this; &#125; public static MleApp getInstance()&#123; return instance; &#125; //新建一个activity public void addActivity(Activity activity)&#123; activities.add(activity); &#125; //结束指定的activity public void finishActivity(Activity activity)&#123; if (activity != null)&#123; activities.remove(activity); activity.finish(); activity = null; &#125; &#125; //exit app public void exitApp()&#123; for (Activity activity:activities)&#123; if (activity != null)&#123; activity.finish(); &#125; &#125; System.exit(0); &#125;&#125; 记得在清单文件AndroidManifest.xml中调用：123456&lt;application android:name=".MleApp" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" ... 有了这个类，可以很方便的在应用的任何地方都可以拿到上下文。 BaseActivity和BaseFragment编写应用时，Activity是必不可少的，它是处理界面组件并呈现给用户的主体，我们以前使用的MVC模式渐渐被MVP所替代，主要原因就是项目复杂时，Activity中需要处理太多的逻辑，导致单个Activity文件很臃肿，而使用MVP可以缓解这种问题。在编写Activity时，需要厘清代码结构，尤其是在onCreate()中，一般处理以下几件事情： 加载界面布局并初始化组件 初始化数据 为组件设置动作监听 逻辑处理 为此，可以编写一个抽象的BaseActivity类，继承于android.app.Activity，在其中定义抽象方法，让其他的Activity继承于BaseActivity，并实现抽象方法即可，这样onCreate()代码就清晰了。如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Description: BaseActivity * Created by L02465 on 2016.11.22. */public abstract class BaseActivity extends Activity implements IBaseView&#123; private ProgressDialog mProgressDialog; //全局的加载Dialog @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); initView(); initData(); MleApp.getInstance().addActivity(this); //将每个Activity加入到List中 &#125; public void initView()&#123; loadViewLayout(); findViewById(); setListener(); &#125; public void initData()&#123; initVariables(); processLogic(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); MleApp.getInstance().finishActivity(this); if (mProgressDialog != null)&#123; mProgressDialog.dismiss(); &#125; &#125; //实现IBaseView方法 @Override public void showMsgDialog(String message) &#123; if (mProgressDialog == null)&#123; mProgressDialog = ProgressDialog.show(this,null,message); mProgressDialog.setCancelable(false); &#125;else&#123; mProgressDialog.setMessage(message); mProgressDialog.show(); &#125; &#125; @Override public void showResDialog(int resId) &#123; if (mProgressDialog == null)&#123; mProgressDialog = ProgressDialog.show(this,null,getResources().getString(resId)); mProgressDialog.setCancelable(false); &#125;else&#123; mProgressDialog.show(); &#125; &#125; @Override public void hideDialog() &#123; if (mProgressDialog != null)&#123; mProgressDialog.hide(); &#125; &#125; //加载布局 protected abstract void loadViewLayout(); //加载页面组件 protected abstract void findViewById(); //事件监听器 protected abstract void setListener(); //初始化变量 protected abstract void initVariables(); //处理逻辑 protected abstract void processLogic();&#125; 当然也有BaseFragment：1234567891011121314151617181920212223242526/** 1. Description: 2. Created by L02465 on 2016.11.22. */public abstract class BaseFragment extends Fragment &#123; private View mView; @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; mView = initView(inflater,container,savedInstanceState); return mView; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); &#125; protected abstract View initView(LayoutInflater inflater,ViewGroup container,Bundle bundle); protected abstract void setListener(); protected abstract void initDatas();&#125; 组件绑定事件在组件绑定事件时，有几种方法： 类直接实现相应动作接口 类中写内部类实现动作接口 为组件直接绑定动作接口 我认为第三种方法比较好，因为在组件较多的页面中，进行走读代码时，想知道组件干了什么事，首先要做的就是找到这个组件，并查看它的绑定事件，使用第三种方法，找到组件时就直接看到它的绑定事件，不像1、2种方法还需要在别处找相应代码，影响效率，而且第三种方法直接在组件上绑定事件，是面向对象的写法，在事件的处理中，尽可能封装成一个个方法，而不要使其显得过于臃肿。 时时刻刻预防空指针异常是很必要的 &gt;&gt;&gt;&gt;&gt; NullPointerException]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书单Reading Lists -1]]></title>
      <url>%2F2016%2F11%2F17%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95Reading-Lists%2F</url>
      <content type="text"><![CDATA[《解忧杂货铺》 东野圭吾 我比任何人都爱你，想要永远和你在一起。如果我放弃比赛就能让你好起来，我会毫不犹豫地放弃。但如果不是这样，我希望坚持我的梦想。因为一直以来追寻着梦想，我才活出了自我，而你喜欢的也正是这样的我。我没有一刻忘记过你，但请让我去追寻梦想吧。 人与人之间情断义绝，并不需要什么具体的理由。就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的事态发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。 《重说中国近代史》 张鸣 中国文化之精髓不在于考据，而在于对经典的阐释，并凭借对经典的发挥创造出新的思想体系 举中国数千年礼义人伦，诗书典则，一旦扫地荡尽，此岂独我大清之变，乃开辟以来，名教之奇变，我孔子、孟子之所痛哭于九泉，凡读书识字者，又焉能袖手坐视，不思一为之所也？ 《嫌疑人X的献身》 东野圭吾《白夜行》 东野圭吾《一个人的朝圣》 蕾秋·乔伊斯 有些事情可以有好几个起点，也可以用不同的方式开始。有时候你以为自己已经展开了新的一页，实际上却可能只是重复以前的步伐。 他发现当一个人与熟悉的生活疏离，成为一个过客，陌生的事物都会被赋予新的意义。 给予和接受都是一份馈赠，既需要谦逊，也需要勇气。 《岛上书店》无人为孤岛，一书一世界 独自生活的难处，在于不管弄出什么样的烂摊子，都不得不自己清理。 我们在二十岁有共鸣的东西到了四十岁的时候不一定能产生共鸣，反之亦然。书本如此，生活亦如此。 一旦一个人在乎一件事，就发现自己不得不开始在乎一切事。 关于政治、上帝和爱，人们都讲些无聊的谎话。想要了解一个人，你只需问一个问题：“你最喜欢那本书？” 生活中每一桩糟糕事，几乎都是时机不当的结果，每件好事，都是时机恰到好处的结果。 我们读书而后知道自己并不孤单。我们读书，因为我们孤单；我们读书，然后就不孤单，我们并不孤单。 《追风筝的人》 胡塞尼读一本书了解一个国家 “当你杀害一个人，你偷走了一条性命，你偷走了他妻子身为人妇的权利，夺走他子女的父亲。当你说谎，你偷走别人知道真相的权利，当你诈骗，你偷走了公平的权利。“ 哈桑就是这样，他真的纯洁得该死，跟他在一起，你永远觉得自己是个骗子。 阿富汗人总喜欢说：生活总会继续。他们不关心开始或结束、成功或失败、危在旦夕或柳暗花明，只顾像游牧部落那样风尘仆仆地缓慢前进。 也许每个人心中都有一个风筝，无论它意味着什么，让我们勇敢地追。 《无声告白》 伍绮诗对子女的教育什么才是最重要的？ 让过去的事情过去，停止问问题，向前看，决不向后看。 你永远得不到你想要的；你只是学会了如何得过且过而已。 对于每一个作用力，都有一个大小相等、方向相反的反作用力，一个向上，另一个向下，一个得到，另一个失去，一个逃离，另一个受困，永远受困。 父母越是关心你，对你的期望就越高，他们的关心像雪一样不断落在你的身上，最终把你压垮。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些Android Debug Bridge命令]]></title>
      <url>%2F2016%2F11%2F14%2Fadb%2F</url>
      <content type="text"><![CDATA[概述 Android Debug Bridge（ADB）是android sdk中的一个工具，用这个工具可以直接操作管理Android模拟器或者连接到计算机的Android设备。ADB是一个客户端-服务器端程序，客户端是操作的电脑，服务端是Android设备 主要功能它的主要功能有： 运行设备的Shell 管理模拟器或设备的端口映射 计算和设备之间上传/下载文件 将本地apk安装到模拟器/真实的Android设备 一些常用命令ADB启动/停止/查看版本adb启动：1adb start-server adb停止：1adb kill-server 查看版本：123C:\Users\DELL&gt;adb versionAndroid Debug Bridge version 1.0.36Revision af05c7354fe1-android 查看设备1adb devices 查看当前连接的设备，以列表的形式显示出来。eg： 123 D:\AndroidStudioProjects\KeepAction&gt;adb devicesList of devices attached3c4711c84670 device 安装apkapk在当前目录：1adb install &lt;apk名称&gt; apk不在当前目录：1adb install &lt;apk的路径&gt; eg：1234C:\Users\DELL&gt;adb install C:\Users\DELL\Desktop\版本\3322\运维\com.maintain.apk[100%] /data/local/tmp/com.mainta pkg: /data/local/tmp/com.maintaSuccess 保留数据和缓存文件，reinstall apk：1adb install -r com.maintain.apk 安装apk到SD卡：1adb install -s com.maintain.apk 卸载apk12adb uninstall &lt;packagename&gt;adb uninstall -k &lt;packagename&gt; eg：12C:\Users\DELL&gt;adb uninstall com.maintainSuccess 加-k参数的话，卸载后会保留app的配置和缓存文件 登录设备shell12adb shelladb shell &lt;command&gt; 这个命令将登录设备的shell。后面加command将直接运行设备命令，相当于执行远程命令 从电脑上发送文件到设备1adb push &lt;本地路径&gt; &lt;远程路径&gt; 本地路径：文件在电脑上的路径远程路径：文件保存到Android设备上的路径使用push把电脑上的文件或者文件夹复制到手机上 从设备上下载文件到电脑1adb pull &lt;远程路径&gt; &lt;本地路径&gt; 使用pull把手机上的文件或者文件夹复制到电脑上 重启手机1adb reboot 对手机进行重启 获取序列号12C:\Users\DELL&gt;adb get-serialno3c4711c84670 获取MAC地址12C:\Users\DELL&gt;adb shell cat /sys/class/net/wlan0/address3c:47:11:c8:34:db 查看设备型号12C:\Users\DELL&gt;adb shell getprop ro.product.modelHUAWEI Y635-CL00 显示包信息(1)列出系统应用的所有包名：123456789C:\Users\DELL&gt;adb shell pm list packages -spackage:com.qualcomm.timeservicepackage:com.android.defcontainerpackage:com.example.android.notepadpackage:com.android.contactspackage:com.huawei.hwidpackage:com.huawei.mmitest2package:com.android.phone... (2)列出除了系统应用的第三方应用包名：1234567C:\Users\DELL&gt;adb shell pm list packages -3package:com.tencent.lightalkpackage:com.uniview.airimos.mlepackage:com.uniview.retrofitdemo_gitpackage:com.uniview.keepactionpackage:com.uniview.imos.sdk... (3)使用find或者findstr列出要找的包名：12C:\Users\DELL&gt;adb shell pm list packages | find "qq"package:com.tencent.mobileqq 清除应用数据与缓存1adb shell pm clear &lt;packagename&gt; 强行停止应用1adb shell am force-stop &lt;packagename&gt; 查看手机Android系统版本1adb shell getprop ro.build.version.release 查看屏幕分辨率12C:\Users\DELL&gt;adb shell wm sizePhysical size: 1080x1920 查看屏幕密度12C:\Users\DELL&gt;adb shell wm densityPhysical density: 480 显示帮助信息1adb help]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android后台定时任务分析]]></title>
      <url>%2F2016%2F11%2F09%2FAndroid%E5%90%8E%E5%8F%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[实现在后台能够稳定的周期性的发送通知，在锁屏状态下收到通知后亮屏。说到后台定时任务，首先想到的是用Service + Timer组合来实现，在Service中启动定时器，在定时器中执行任务，但这种方式存在一个问题，就是定时任务间隔时间较长时，后台Service很容易被Android 系统kill掉，主要是因为Android自带的内存清理，内存不足时就会被kill，这样任务肯定不能定时执行，达不到想要的结果。为了解决这种问题，可以使用 前台服务，这种服务一直保持运行状态，不会由于内存不足被回收，它与Service的最大区别在于，它会一直显示在系统的状态栏，和Notification的效果很相似。 使用前台服务进行通知12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Description: * Created by L02465 on 2016.11.09. */public class MyService extends Service &#123; private static final int ONGOING_ID = 1; private Timer mTimer; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; startTimer(); return super.onStartCommand(intent, flags, startId); &#125; public void startTimer()&#123; if (mTimer == null) &#123; mTimer = new Timer(); &#125; mTimer.schedule(new TimerTask() &#123; @Override public void run() &#123; showNotification(); &#125; &#125;,1000,1000 * 60 * 1); //1s之后 每隔1分钟运行一次 &#125; @Override public void onDestroy() &#123; super.onDestroy(); stopForeground(true); //停止前台服务 &#125; //发送通知 public void showNotification()&#123; //点击通知进行跳转 Intent toMain = new Intent(this,MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this,0,toMain, PendingIntent.FLAG_UPDATE_CURRENT); Notification notification = new Notification.Builder(this) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setSmallIcon(R.drawable.ic_cached_black_24dp) //设置小图标是需要的，否则显示的通知内容不是自定义的内容 .setContentIntent(pi) //单击通知后进行跳转 .setContentTitle("Hello:") .setContentText("快起来走动走动，不然对身体不好...") .setDefaults(Notification.DEFAULT_VIBRATE) //通知来了进行震动 .build(); startForeground(ONGOING_ID,notification); //启动前台服务 &#125; 运行结果： 代码主要调用了startForeground()来启动前台服务，每隔1分钟进行通知，在状态栏显示出来。调用stopForeground(true);停止前台服务，会让状态栏的通知显示取消掉。使用Service+Timer组合看似可以稳定的在后台运行，但也存在问题：就是在连接USB进行调试，按下电源键锁屏状态下会运行正常，当拔掉USB线，锁屏下会发现并没有按设定的间隔进行通知，在打开手机后又开始通知的情况 使用AlarmManager Android中的一种系统级别的提示服务，在特定的时间广播一个指定的Intent，可以实现从指定时间开始，以一个固定的时间间隔去执行某项操作，同样可以当做一个定时器去使用。（1）可以在指定时长后去执行某项操作（2）可以周期性的执行某项操作 AlarmManager常用的三个方法以及闹钟类型123456/** * @param type 闹钟类型 * @param triggerAtMillis 闹钟执行时间 * @param operation 执行的动作 * */public void set(int type, long triggerAtMillis, PendingIntent operation) 用于执行一次性闹钟，在指定的时间去执行动作12345678/** * @param type 闹钟类型 * @param triggerAtMillis 闹钟执行时间 * @param intervalMillis 间隔时间 * @param operation 执行的动作 * */public void setRepeating(int type, long triggerAtMillis, long intervalMillis, PendingIntent operation) 用于执行重复闹钟，在指定时间周期性的执行动作12345678/** * @param type 闹钟类型 * @param triggerAtMillis 闹钟执行时间 * @param intervalMillis 间隔时间 * @param operation 执行的动作 * */public void setInexactRepeating(int type, long triggerAtMillis, long intervalMillis, PendingIntent operation) 与第二种类似，在触发时间不精确的情况下需要。 闹钟类型 状态值 描述 ELAPSED_REALTIME 3 在睡眠状态下不可用，使用相对时间 ELAPSED_REALTIME_WAKEUP 2 在睡眠状态下唤醒系统并执行提示，使用相对时间 RTC 1 在睡眠状态下不可用，使用绝对时间 RTC_WAKEUP 0 在睡眠状态下唤醒系统并进行提示，使用绝对时间 POWER_OFF_WAKEUP 4 在手机关机状态下也能进行提示，使用绝对时间 相对时间：相对系统开启时间，当前相对时间就是SystemClock.elapsedRealtime()绝对时间：当前时间System.currentTimeMillis() Usage5分钟之后去开启另一个服务：12345678public void startAlarm()&#123; AlarmManager manager = (AlarmManager)getSystemService(ALARM_SERVICE); int minutes = 1000 * 60 * 5; // 5minutes Intent toService = new Intent(this,MyService.class); PendingIntent pi = PendingIntent.getService(this,0,toReceiver,0); long firstTime = SystemClock.elapsedRealtime() + minutes; //相对时间 manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,firstTime,pi); &#125; 每隔5分钟开启另一个服务：12345678public void startAlarm()&#123; AlarmManager manager = (AlarmManager)getSystemService(ALARM_SERVICE); int minutes = 1000 * 60 * 5; // 5minutes Intent toService = new Intent(this,NoticeService.class); PendingIntent pi = PendingIntent.getService(this,0,toService,0); long firstTime = SystemClock.elapsedRealtime(); manager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,firstTime,minutes,pi); &#125; 在新的服务NoticeService开启时，执行通知的代码，可以正常进行通知，拔掉USB线并锁屏后，也会每隔5分钟按时进行通知，基本稳定。AlarmManager的setRepeating()方法和Timer的Schedule(task,delay,peroid)类似。也可以定时进行广播，在广播接收器中执行操作：12Intent toReceiver = new Intent(this,MyBroadcast.class);PendingIntent pi = PendingIntent.getBroadcast(this,0,toReceiver,0); AlarmManager取消需要注意的是取消的Intent必须与启动Intent保持一致才能取消AlarmManager1234AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);Intent intent = new Intent(this,NoticeService.class);PendingIntent pi = PendingIntent.getService(this,0,intent,0);manager.cancel(pi); 通知亮屏代码1234567891011121314public void lightScreen(Context context)&#123; PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE); boolean isScreenOn = powerManager.isScreenOn(); LogUtil.e("task : screen on &gt;&gt;&gt; " + isScreenOn); if (isScreenOn == false)&#123; PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.ON_AFTER_RELEASE,"MyLock"); wakeLock.acquire(1000); PowerManager.WakeLock wakeLock_cpu = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,"MyCpuLock"); wakeLock_cpu.acquire(1000); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio中的一些快捷键]]></title>
      <url>%2F2016%2F11%2F02%2FAndroid-Studio%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[Log 打印生成类的TAG：logt1private static final String TAG = "MainActivity"; 在方法中打印日志：logd1Log.d(TAG, "onCreate: "); 在方法中打印方法名和参数信息：logm1Log.d(TAG, "onCreate() called with: " + "savedInstanceState = [" + savedInstanceState + "]"); 还有loge、logi、logr、logw。 代码的移动代码提示：ctrl + alt + 空格代码行上移/下移：ctrl + shift + up/down复制代码行到下一行：ctrl + D剪切一行代码：ctrl + X删除一行代码：ctrl + Y光标在方法上移动：alt + up/down 代码查看打开一个类：ctrl + N打开一个文件：ctrl + shift + N查看类的声明：ctrl + B查看父类：ctrl + U查看方法的调用：ctrl + alt + H在类中查看方法的实现：ctrl + shift + I查看类的继承结构：ctrl + H工程面板的显示与隐藏：alt + 数字1查看一个类中的所有方法：ctrl + F12查看父类中的方法并选择复写：ctrl + O 代码块生成：ctrl + J查找：ctrl + F替换：ctrl + R打开最近的模板：ctrl + E 根据自身使用习惯，也可以在Android Studio的 File --&gt; Settings ---&gt; keymap 中改变默认的快捷键，来提高开发效率。 快捷代码块 fori 和 foreach 123for (int i = 0; i &lt; ; i++) &#123; &#125; .null 和 .nn：在变量名后面使用，快捷检测是否为null。 12345678Bundle bundle = getIntent().getExtras();if (bundle == null) &#123; &#125; if (bundle != null) &#123; &#125; const 随机生成一个符合android style的final int， 1private static final int = 181; key 生成一个以KEY_ 开头的final String 1private static final String KEY_ = ""; fbc 快捷生成findViewById 1() findViewById(R.id.); visible 和 gone : 123Button myBut = new Button(this);.setVisibility(View.GONE);.setVisibility(View.VISIBLE); starter 和 newInstance : 123456789101112131415public static void start(Context context) &#123; Intent starter = new Intent(context, Main2Activity.class); starter.putExtra(); context.startActivity(starter); &#125; //------------------------------// public static Fragment newInstance() &#123; Bundle args = new Bundle(); Fragment fragment = new Fragment(); fragment.setArguments(args); return fragment; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[将自己的库发布到maven]]></title>
      <url>%2F2016%2F10%2F27%2F%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%93%E5%8F%91%E5%B8%83%E5%88%B0maven%2F</url>
      <content type="text"><![CDATA[什么是maven?官网网站：Apache Maven Project Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of information. Apache Maven是一个软件项目管理和理解工具。基于项目对象模型（POM）的概念，Maven可以管理一个项目的构建，从主要的信息模块报告和收集资料。 maven是一个项目管理工具，它包含了一个项目对象模型（Project Object Model），一组标准集合，一个项目生命周期，一个依赖管理系统，maven可以很方便的管理项目报告，生成站点，管理JAR文件等。 发布library到mavenmaven作为一个中心仓库，在Android开发中，可以将自己写的lib发布到maven，并使用Sonatype Nexus进行管理。仓库信息：123456Repository ID: airimosRepository Name: airimosRepository Type: hostedRepository Policy: ReleaseRepository Format: maven2Contained in groups: 123456&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;airimos&lt;/id&gt; &lt;url&gt;http://maven.airimos.com/nexus/content/repositories/airimos&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; 使用Android studio，在自己库的src同级目录下的build.gradle中进行一些配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990apply plugin: 'com.android.library'apply plugin: 'maven'android &#123; compileSdkVersion 23 buildToolsVersion "23.0.2" defaultConfig &#123; minSdkVersion 14 targetSdkVersion 23 versionCode 1 versionName "1.0" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.1.1'&#125;tasks.withType(JavaCompile)&#123; options.encoding = "UTF-8"&#125;Properties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())def isReleaseBuild() &#123; return VERSION_NAME.contains("SNAPSHOT") == false&#125;def getRepositoryUsername() &#123; return hasProperty("NEXUS_USERNAME") ? properties.getProperty("NEXUS_USERNAME") : ""&#125;def getRepositoryPassword() &#123; return hasProperty("NEXUS_PASSWORD") ? properties.getProperty("NEXUS_PASSWORD") : ""&#125;afterEvaluate &#123; project -&gt; uploadArchives &#123; repositories &#123; mavenDeployer &#123; pom.groupId = properties.getProperty("GROUP") pom.artifactId = properties.getProperty("POM_ARTIFACT_ID") pom.version = properties.getProperty("VERSION_NAME") repository(url: properties.getProperty("RELEASE_REPOSITORY_URL")) &#123; authentication(userName: properties.getProperty("NEXUS_USERNAME"), password: properties.getProperty("NEXUS_PASSWORD")) &#125; snapshotRepository(url: properties.getProperty("SNAPSHOT_REPOSITORY_URL")) &#123; authentication(userName: properties.getProperty("NEXUS_USERNAME"), password: properties.getProperty("NEXUS_PASSWORD")) &#125; &#125; &#125; &#125; task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = 'sources' from android.sourceSets.main.java.sourceFiles &#125; task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) &#125; task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir &#125; javadoc &#123; options &#123; encoding "UTF-8" charSet 'UTF-8' author true version true &#125; &#125; artifacts &#123; archives javadocJar archives sourcesJar &#125;&#125; 配置项目根目录下的local.properties文件 12345678sdk.dir=D\:\\Android\\SdkGROUP=com.uniview.usbcameralibVERSION_NAME=1.0.0POM_ARTIFACT_ID=usbcameralibRELEASE_REPOSITORY_URL=http\://maven.airimos.com/nexus/content/repositories/airimosSNAPSHOT_REPOSITORY_URL=http\://maven.airimos.com/nexus/content/repositories/airimosSnapNEXUS_USERNAME=usernameNEXUS_PASSWORD=password 这些配置的信息，会在第一步添加的代码读取到。 GROUP：将lib发布到maven的哪个仓库组中，这里的仓库名字为airimos，会发布到airimos下的com/uniview/usbcameralib中。 VERSION_NAME： 库的版本号 POM_ARTIFACT_ID： 库的名称 RELEASE_REPOSITORY_URL：正式仓库地址 SNAPSHOT_REPOSITORY_URL： 不稳定仓库地址 NEXUS_USERNAME ：Sonatype Nexus的用户名 NEXUS_PASSWORD：Sonatype Nexus的密码 在Android studio右侧的Gradle projects中，双击 uploadArchives上传到maven服务器，将会进行构建，显示BUILD SUCCESSFUL则表示成功。 以后每次对库进行更新后，将库的版本号增加，在使用的项目中重新下载就好。 依赖上传的库 在新建的项目中使用库，在项目的根目录下的build.gradle配置： 12345repositories &#123; jcenter() //配置maven仓库地址 maven &#123; url 'http://maven.airimos.com/nexus/content/repositories/airimos/' &#125; &#125; 在src同级目录下的build.gradle进行依赖： 1234567dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.1.1' //依赖该库 compile 'com.uniview.usbcameralib:usbcameralib:1.0.0'&#125; 仓库类型maven中的仓库分为两种：snapshot快照仓库和release 发布仓库。snapshot快照仓库用于保存开发过程中的不稳定版本，release正式仓库用来保存稳定的发行版本，当定义一个组件或者模块为快照版本时，只需要在pom文件中在该模块的版本号后加上-SNAPSHOT（要大写）即可。1&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; maven2会根据模块的版本号中是否带有-SNAPSHOT来判断是快照版本还是正式版本，如果是快照版本在部署时会自动发布到快照版本库中，而使用快照版本的模块，在不更改版本号的情况下，直接编译打包时，maven会自动从镜像服务器上下载最新的快照版本；如果是正式版本，那么在部署时会自动发布到正式版本库中，而使用正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块，则不会主动去镜像服务器上下载。因此在开发阶段，可以将共用库的版本设置为快照版本，而依赖组件则引用快照版本进行开发，在共用库的快照版本更新后，也不需要修改pom文件的版本号来下载新的版本，直接执行相关编译、打包命令即可重新下载最新的快照库，方便开发。开发完毕后，就可将该库发布到release正式版本库中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[了解流媒体]]></title>
      <url>%2F2016%2F10%2F23%2F%E4%BA%86%E8%A7%A3%E6%B5%81%E5%AA%92%E4%BD%93%2F</url>
      <content type="text"><![CDATA[基本概念流媒体相关的一些基础概念：帧： 一帧就是一副静止的图像帧率： 每秒显示的图片数，影响画面流畅度，与画面流畅度成正比；帧率越大，画面越流畅，帧率越小，画面越有跳动感； 由于人类眼睛的特殊生理结构，如果看到画面的帧率 &gt; 16的时候，会感觉这个画面是连贯的，此现象称之为视觉暂留，并且当帧率达到一定数值后，在增长的话，人眼也不容易察觉到有明显的流畅度提升。 码率： 图片进行压缩后每秒显示的数据量分辨率： 图片的长度和宽度，也就是图片的尺寸GOP： （Group of Pictures）画面组，一个GOP就是一组连续的画面，每个画面都是一帧，一个GOP就是很多帧的集合。 直播平台的视频数据，就是一组图片，包括I帧、B帧、P帧，当用户第一次观看的时候，会寻找I帧，而播放器会到服务器寻找到最近的I帧反馈给用户，因此GOP cache增加了端到端延迟，因为它必须要拿到最近的I帧。GOP cache的长度越长，画面质量越好 流媒体开发： 网络层（socket）负责传输，协议层（rtmp）负责打包数据，封装层（flv、ts）负责编解码数据的封装，编码层（h.264）负责图像音频的压缩压缩前的数据量： 帧率 * 分辨率压缩比： 压缩前的数据量和压缩后的数据量的比值，也就是（帧率 * 分辨率）/ 码率 对于同一个视频源并采用同一种视频编码算法，则压缩比越高画面质量越差 视频文件格式： 音视频文件的后缀，比如 .avi、.mp4、.mp3、.rmvb 根据文件的格式，系统判断使用什么软件打开视频文件随意修改文件格式，对文件本身不会造成太大的影响，比如把avi改成mp4，文件还是avi 视频封装格式： 一种存储视频信息的容器，流式封装可以有TS、FLV等，索引式的封装有mp4、avi等 主要的作用：一个视频文件往往包含图像和音频信息，还有一些配置信息（比如编解码信息，图像和音频的关联等），这些内容需要按照一定的规则组织、封装起来一般视频文件格式的后缀名采用相应的视频封装格式名称，所以视频文件格式就是视频封装格式 视频处理视频处理原理： 视频最终也是通过GPU，一帧一帧渲染到屏幕上的，所以可以使用OpenGL ES，对视频进行加工处理，使视频呈现出不同的效果 现在各种美颜和视频添加特效的app都是利用GPUImage这个框架来实现的 视频处理框架： GPUImage：是基于OpenGL ES的一个强大的图像视频处理框架，封装好了各种滤镜，也可以编写自定义的滤镜，其本身内置了多达120种常见的滤镜效果 OpenGL：(Open Graphics Library)定义了一个跨编程语言、跨平台的编程接口的规格，用于二维三维图像，是一个很专业的图形程序接口，功能强大，调用方便的底层图形库 Open GL ES：是Open GL三维图形API子集，针对手机和游戏主机等嵌入式设备而设计 视频编解码视频压缩编码标准： 对视频进行压缩（视频编码）和解压缩（视频解码）的编码技术 主要作用：是将视频像素数据压缩成视频码流，从而降低视频的数据量，如果视频不经过压缩编码的话，都是很大的。影响视频质量的是其视频编码数据和音频编码数据，跟封装格式没有多大关系 MPEG： 一种视频压缩方式，它采用了帧间压缩，仅存储连续帧之间有差异的地方，从而达到较大的压缩比H.264： 一种视频压缩方式，采用事先预测和与MPEG中的P-B帧一样的帧预测方式压缩，它可以根据需要产生适合网络情况传输的视频流，还有更高的压缩比，有更好的图像质量 如果从单个画面清晰度比较，MPEG有优势，从连贯性上比较的话，H.264有优势；H.264算法复杂，需要更多的处理器和内存资源，对系统要求较高 H.265： 基于H.264，对一些相关技术进行改进，改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化 H.265更高效，能够在同等画质效果下将内容的体积压缩的更小，传输时更快更省带宽 FFmpeg： 是一个跨平台的开源视频框架，能实现视频编码、解码、转码、串流、播放等功能，支持的视频格式以及播放协议非常丰富，几乎包含了所有音视频编解码、封装格式以及播放协议 I/B/P帧，帧内、帧间I帧： 也是关键帧，保留一副完整的画面，解码时只需要本帧数据就可以完成P帧： 差别帧，保留这一帧跟之前帧的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终的画面 P帧没有完整画面数据，只有与前一帧画面差别的数据 B帧： 双向差别帧，保留本帧与前后帧之间的差别，解码时B帧不仅要取得之前的缓存画面，还有解码之后的画面，通过前后画面与本帧数据的叠加取得最终的画面 B帧压缩率高，但解码是CPU工作较多 帧内压缩： 当压缩一帧图像时，仅考虑本帧数据而不考率相邻帧之间冗余信息 帧内压缩一般采用有损压缩算法 帧间压缩：时间压缩，通常比较时间轴上不同帧之间的数据进行压缩 帧间压缩一般是无损的 合成： 将视频流、音频流甚至是字幕流封装到一个文件中，作为一个信号进行传输 流媒体服务器SRS： 优秀开源的流媒体服务器系统BMS： SRS的商业版，有更多的功能nginx： 免费开源web服务器，常用来配置流媒体服务器数据分发（CDN）： 将内容分发到网络，发布到最接近用户的网络边缘，使用户更容易拿到内容，解决网络拥堵状况，提高用户访问网站的响应速度CDN工作原理： 上传流媒体数据到源服务器 源服务器保存流媒体数据 客户端播放流媒体数据时，向CDN请求编码后的流媒体数据 CDN的服务器响应请求，如果节点上不存在该流媒体数据，则向源服务器请求流媒体数据，如果存在，则执行6 源服务器响应CDN的请求，将流媒体分发到响应的CDN节点上 CDN将流媒体数据发到客户端 负载均衡： 由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无需其他服务器的辅助。通过某种负载分担技术，将外部发送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求 负载均衡能够平均分配客户请求到服务器列阵，以提供快速获取数据，解决大量并发访问服务器问题 解码硬解码： 用GPU来解码，减少CPU运算 优点：播放流畅，低功耗，解码速度快缺点：兼容性不好 软解码： 用CPU解码 优点：兼容性好缺点：加大CPU负担，不够流畅，解码速度相对慢，耗电增加]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Retrofit进行图片的上传]]></title>
      <url>%2F2016%2F10%2F18%2FRetrofit%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%2F</url>
      <content type="text"><![CDATA[目标：使用Retrofit将本地图片上传至服务器指定的文件夹中。服务端接口：入参，使用表单的形式。 表单字段名 类型 说明 “file” File 上传图片的File对象 “filename” String 上传图片的文件名称 请求地址：http://208.208.91.150:8080/VIID-V5/image/updateimage 上传图片Api12345678910public interface UploadPicApi&#123; @Multipart @POST("image/updateimage") Call&lt;ErrorBean&gt; uploadPic ( @Header("Authorization")String authorization, @Part MultipartBody.Part image, @Part("filename") RequestBody filename );&#125; 接口中的参数可以参考这篇文章：Retrofit入门介绍 – 参数注解 上传图片Service12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class UploadPicService&#123; private static UploadPicApi api; //上传图片结果的回调 public interface IUploadPicListener&#123; void uploadSuccess(); void uploadFailed(String errorMsg); &#125; /** * 包装图片上传接口 * * @param token 登录返回的access_token * @param path 图片路径 * @param fileName 图片名称 * @param listener 结果回调 * */ public static void uploadPic(String token, String path, String fileName, final IUploadPicListener listener)&#123; api = RetrofitClient.getClient().create(UploadPicApi.class); //生成文件对象 File file = new File(path + fileName); //指定内容类型为"image/png" RequestBody photoRequestBody = RequestBody.create(MediaType.parse("image/png"), file); //MultipartBody.Part 被用来发送真实的文件名 MultipartBody.Part photo = MultipartBody.Part.createFormData("file", fileName, photoRequestBody); //由于服务端要求，文件名不能包含后缀，因此去掉后缀 String name = getFileNameNoEx(fileName); //调用上传接口 api.uploadPic(token,photo,RequestBody.create(MediaType.parse("text"),name)).enqueue(new Callback&lt;ErrorBean&gt;()&#123; @Override public void onResponse(Call&lt;ErrorBean&gt; call, Response&lt;ErrorBean&gt; response) &#123; if (null == response)&#123; onFailure(null,new Throwable("upload picture failed:响应为空")); return; &#125; if (null == response.body())&#123; onFailure(null,new Throwable("upload picture failed:响应消息体为空")); return; &#125; //错误码 == 0 表示上传成功，其他均为失败 if (response.body().getErrorCode() == 0)&#123; listener.uploadSuccess(); &#125;else&#123; listener.uploadFailed("错误码:" +response.body().getErrorCode() + "\n错误描述:"+response.body().getErrorMsg()); &#125; LogUtil.d("-----&gt; upload picture successful !"); &#125; @Override public void onFailure(Call&lt;ErrorBean&gt; call, Throwable t) &#123; listener.uploadFailed(t.toString()); &#125; &#125;); &#125; //去掉文件后缀 //参数：完成的文件名称 ， ***.jpg public static String getFileNameNoEx(String fileName)&#123; if((fileName != null) &amp;&amp; (fileName.length() &gt; 0))&#123; int dot = fileName.lastIndexOf("."); if((dot &gt; -1) &amp;&amp; (dot &lt; (fileName.length())))&#123; return fileName.subString(0, dot); &#125; &#125; return fileName; &#125;&#125; 使用这个接口就可以完成单张图片的上传了。如果需要上传多个图片，就在接口中声明多个Part参数，也可以使用PartMap。多张图片上传可以参考这篇文章：Android Retrofit 实现文字（参数）和多张图片一起上传在编写接口时，需要与服务端配合，保持一致，主要是请求消息头的构造，构造错误的话，那么上传基本是失败的。123@Multipart@POST("image/updateimage")Call&lt;ErrorBean&gt; uploadMultiPic(@Part("data") String text, @PartMap Map&lt;String,RequestBody&gt; params); 关键代码：123456789101112131415161718public void uploadMultiPic()&#123;String image1 = "/sdcard/myimage/" + "happy.png";String image2 = "/sdcard/myimage/" + "xixi.png";List&lt;String&gt; pathList = new ArrayList&lt;&gt;(); //文件路径集合pathList.add(image1);pathList.add(image2);Map&lt;String,RequestBody&gt; requestBodyMap = new Hash&lt;&gt;();if(pathList.size() &gt; 0)&#123; for(int i = 0; i &lt; pathList.size();i++)&#123; File file = new File(pathList.get(i)); requestBodyMap.put("file"+i + "\";"filename=\""+file.getName(),RequestBody.create(MediaType.parse("image/png"),file); &#125;&#125;//调用上传接口api.uploadMultiPic("some pictures",requestBodyMap)&#123; //TODO：回调处理&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit+OkHttp缓存数据]]></title>
      <url>%2F2016%2F10%2F12%2FRetrofit-OkHttp%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[Retrofit本身并不能缓存，从版本2.0开始默认支持缓存，底层的网络连接都依赖于Okhttp ，因此数据缓存也需要在Okhttp上处理。Okhttp的版本不同，其缓存方式也不同。 为什么使用缓存？减少服务器负荷，降低网络延迟提升用户体验，复杂的缓存处理会根据用户当前的网络情况采取不同的策略，在网络好的时候缓存时间短，数据更新快，在网络差的时候，提高缓存使用的时间，缓存策略不仅仅与网络好坏有关，也与应用本身的用途、业务需求、接口有关，比如应用的数据变更不多，则对缓存使用就比较多，有的应用要保证数据的实时性，比如股票信息，这时就不考虑缓存，如果是天气信息，则可以根据情况设定短的缓存时间，因此应用是否需要缓存，要根据不同的情况作分析，给出不同的方案。在开发App时，在有网络时调用MobileApi接口，请求新的数据，在断网情况下，可以给用户进行断网提示，但有些需求需要在断网时也显示数据，这时就可以使用缓存。由于Retrofit 本身没有缓存处理，则需要自定义拦截器来实现缓存功能。 定义拦截器版本：Retrofit: 2.1.0 +Okhttp 3.3.0：首先，判断是否有网，有网时请求数据，并保存到缓存中，无网时读取缓存。要使用到CacheControl类，该类主要负责缓存策略的控制，主要有以下策略： FORCE_CACHE ：只走缓存 FORCE_NETWORK ：只走网路 定义拦截器：1234567891011121314151617181920212223242526272829303132333435363738394041424344//拦截器： Interceptor interceptor = new Interceptor() &#123; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; // 对请求进行拦截：无网络是强制读取缓存 Request request = chain.request(); if (!NetworkUtil.hasNetwork(getApplicationContext()))&#123; request = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE) .build(); &#125; //对响应进行拦截 //有网络时，移除header，设置缓存超时时间为1小时 okhttp3.Response response = chain.proceed(request); if (NetworkUtil.hasNetwork(getApplicationContext()))&#123; int maxAge = 60 * 60; //1小时 response.newBuilder() .removeHeader("Pragma") .header("Cache-Control","public,max-age="+maxAge) .build(); &#125;else &#123; //无网络时，缓存时间为1周 int maxScale = 60 * 60 * 24 * 7; // 1周 response.newBuilder().removeHeader("Pragma") .header("Cache-Control","public, only-if-cached, max-stale="+maxScale) .build(); &#125; return response; &#125; &#125;; //判断是否连接网络 public static void hasNetwork(Context context)&#123; if(context != null)&#123; ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (cm != null)&#123; NetworkInfo info = cm.getActiveNetworkInfo(); if (info != null)&#123; return info.isAvailable(); &#125; &#125; &#125; return false; &#125; 给Okhttp设置拦截器：12345678910111213//缓存目录 File cacheFile = new File(context.getExternalCacheDir(),"mycache"); //缓存大小为20M Cache cache = new Cache(cacheFile, 1024 * 1024 * 20); //创建OkhttpClient，添加拦截器和缓存 OkHttpClient client = new OkHttpClient().newBuilder() .addInterceptor(interceptor).cache(cache).build(); //生成Retrofit，并将OkHttpClient对象写入 Retrofit mRetrofit = new Retrofit.Builder() .baseUrl(BaseUrl) .addConverterFactory(GsonConverterFactory.create()) .client(client) .build(); 缓存基本实现，运行程序后，会在SdCard中的/Android/data/应用包名/cache/mycache目录下看到缓存文件，当应用卸载后，/Android/data/应用包名/这个目录所有文件被删除，不会留下垃圾信息。在设置----&gt;应用 ----&gt;应用详情里面进行清除缓存也会清理缓存文件，对应上面所说目录。在拦截器中的两个字段max-age和max-stale不是很理解，资料较少，有以下比较： 介绍 max-age 强制响应缓存者，根据该值，校验新鲜性。即使用自身的Age值，与请求时间做比较，如果超出max-age，则强制去服务端校验，以确保返回一个新鲜的响应 max-stale 允许缓存者，发送一个过期不超过指定时间的旧缓存 即使看了这个比较，对此理解也不是很深刻，如果有那位看到，可以留言讨论下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github文件夹为灰色解决办法]]></title>
      <url>%2F2016%2F10%2F10%2FGithub%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%BA%E7%81%B0%E8%89%B2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[问题原因：在灰色的文件中包含其他仓库，也就是含有.git文件夹和.gitignore文件。解决办法：删除目录下的.git文件夹和.gitignore文件，重新进行commit和push。 如果删除之后没有用，可以尝试下面的方法：删除该目录的缓存，在Git Bush窗口中敲如下命令：我的项目根目录下themes/landspace为灰色，则敲入的命令为： 1234git rm -r --cached themes/landspacegit add .git commit -m "remove cahce"git push origin branch-name 提交后，刷新github网页查看该目录是否为灰色。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片加载库Glide学习总结]]></title>
      <url>%2F2016%2F10%2F08%2F%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93Glide%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[最近的项目需要加载图片，小白就上网寻找这方面的资料，项目的架构为MVP+Retrofit，典型的网络数据请求,看了比较多的资料，于是决定使用Glide,因为数据的呈现方式都是使用ListView,用了才知道该库很牛,于是对接触到的知识点稍微归纳一下，整理学习。 图片加载一直是一个比较棘手的事情，俗话说就是“坑”比较多，于是就google了一下这方面的库，有很多图片库，例如Picasso, Universal-Image-Loader,Fresco,Glide等，这些库都是很火的，使用量很大的图片库， 他们各有优点，不能评说那一个不好，根据项目的需求适当选择。 几个库的简单比较 Picasso：是Square出品的图片库，当然是很厉害的，该公司还有响当当的Okhttp和Retrofit，都是很牛逼的网络请求库,搭配使用效果可能更好一些，之所以这么说是因为Picasso可以将网络请求到的数据缓存交给Okhttp来处理。 Universal-Image-Loader：一个强大的图片加载库，包含的配置比较多，使用很广泛，很老牌。 Fresco：是Facebook出品的，也超强大。从知乎问答下看到该库最大的优点是5.0以下（最低2.3）的bitmap加载，在5.0以下，会将图片放到一个特别的内存存储区，称为：Ashmem区，在图片不显示的时候也会自动清除内存（这个是必须的），使得App更加流畅，减少图片内存占用引发的内存不足（OOM）。 Glide：谷歌推荐使用的图片加载库，Google一些图片应用就使用该库进行图片加载，用起来很流畅，可以说是在Picasso上的进一步扩展，比如支持Gif动态图，在使用时可以传入更多的上下文等等，他们两者最大的区别在于默认的设置不同，比如默认的图片格式不同，尺寸大小也不同等，在下面的链接文章中有具体的对比分析。 总结：Glide是Picasso的进一步扩展，Picasso能做的Glide也可以做，无非就是配置的不同。 网上关于Picasso和Glide性能进行比较的文章挺多，不过遗憾的是，大多数都是抄来抄去的，比较清晰的是这篇：Google推荐的图片加载库Glide介绍，Picasso和Glide的使用极其相似，但也有不少细节上的区别，看了这篇文章可以大致了解一二。 现在整理一下Glide的使用： 配置Glide在Module根目录下的build.gradle中进行库依赖： 12345def def latestVersion = '3.7.0'dependencies &#123; compile 'com.github.bumptech.glide:glide:$latestVersion' compile 'com.android.support:support-v4:19.1.0'&#125; Glide需要依赖Support Library v4。然后同步一下代码build successful,就可以使用Glide了。 使用Glide使用下面一段代码就能实现图片加载，看起来极其简单方便：123456//图片的urlprivate String image_url = "https://www.image.com/myimage?id=1";private ImageView imageView = (ImageView)super.findViewById(R.id.image);Glide.with(context) .load(image_url) .into(imageView); 用这段代码就可以将url所表示的图片装到ImageView显示出来，是不是很爽呢？with里面的参数相比Picasso不仅仅接受上下文Context对象，还可以是Activity，Fragment，FragmentActivity等，这样可以更好的让加载图片的请求与生命周期动态管理起来。Glide不仅仅支持加载网络图片，还支持以下几种加载方式： 加载资源文件：DrawableTypeRequest&lt;Integer&gt; load(Integer resourceId) 1Glide.with(context).load(R.drawable.my_image).into(imageview); 加载本地文件：DrawableTypeRequest&lt;File&gt; load(File file) 12File file = new File("sdcard/myimage/","image.jpg");Glide.with(context).load(file).into(imageView); 加载Uri：DrawableTypeRequest&lt;Uri&gt; load(Uri uri) 1234File file = new File(Environment.getExternalStorageDirectory() + File.separator + "image", "image.jpg");Uri uri = Uri.fromFile(file);Glide.with(context).load(uri).into(imageView); String加载：DrawableTypeRequest&lt;String&gt; load(String string) 设置占位图片placehold图片加载并不是很实时的，加载成功的时间是不确定的，在加载时，可以设置一个图片显示在ImageView上进行一些正在加载...提示等等。 1234Glide.with(context) .load(image_url) .placehold(R.drawable.loading) .into(imageView); error在加载网络图片时，如果突然网络断掉，肯定加载不到正确的图片，这时可以设置一个错误图片到ImageView,提示用户加载失败。 1234Glide.with(context) .load(image_url) .error(R.drawable.loaderror) .into(imageView); 当然，也可以给Glide设置监听，当图片加载失败时，可以知道为什么加载失败了。 123456789101112131415161718//设置加载图片错误时的监听RequestListener&lt;String,GlideDrawable&gt; loadErrorListener = new RequestListener&lt;String,GlideDrawable&gt;()&#123; @Override public boolean onException(Exception e,String model,Target&lt;GlideDrawable&gt; target,boolean isFirstResource)&#123; //加载异常时回调 Log.e(TAG,"exception:" + e.toString); &#125; @Override public boolean onResourceReady(GlideDrawable resource,String model,Target&lt;GlideDrawable&gt; target,boolean isFromMemoryCache,boolean isFirstResource)&#123; //加载成功时的回调 //... &#125;&#125;;Glide.with(context) .load(image_url) .listener(loadErrorListener) .into(imageView); 图片的调整Glide加载图片大小根据ImageView尺寸自动调整的，在缓存的时候也是按照图片大小进行缓存，每一种尺寸都会保留一份缓存。并且可以调用override(int width,int height)在图片显示到ImageView之前改变图片大小，width和height的单位都是px。 1234Glide.with(context) .load(image_url) .override(64,64) .into(imageView); 缩放：Glide提供了两种图形转换的标准选项：centerCrop()和fitCenter； centerCrop() 这个可以对图像进行裁剪，当图片比ImageView大的时候，会将超出ImageView的部分裁剪掉，尽可能让ImageView完全填充，但图像可能不会全部显示 1234Glide.with(context) .load(image_url) .centerCrop() .into(imageView); fitCenter() 它会自适应ImageView的大小，并且会完整的显示在ImageView中，但是ImageView可能不会被完全填充 设置缩略图支持 1234Glide.with(context) .load(image_url) .thumbnail(0.1f) .into(imageView); 设置动态转换在图片显示之前，可以通过transformation对其做一些处理，已达到想要的图片效果，为此，需要创建一个类，该类实现了Transformation接口，如果只是对图片进行转换，则可以直接使用Glide封装好的BitmapTransformation抽象类，图像的转换只需要在transform里实现，并重写getId()方法，该方法返回此次转换的唯一标识，要确保唯一性。 12345678910111213141516public class GlideRoundTransform extends BitmapTransformation&#123; @Override protected Bitmap transform(BitmapPool pool,Bitmap toTransform,int outWidth,int outHeight)&#123; //转换处理 &#125; @Override public String getId()&#123; return getClass().getName + Math.random(); &#125;&#125;Glide.with(context) .load(image_url) .transform(new GlideRoundTransform()) .into(imageView); 当图片需要多个转换时，将每种的转换类对象传入到transform()即可。 1234Glide.with(context) .load(image_url) .transform(new GlideRoundTransform(this),new GlideOtherTransform(this)) .into(imageView); 加载的动画为了使图片平滑的加载到ImageView，可以设置加载的动画效果，最新的api已经默认实现了一个渐入渐出的动画效果，默认时间300ms，也可以使用crossFade，它接受无参或者一个int型的参数，用来指定动画执行的时间。 1234Glide.with(context) .load(image_url) .crossFade(2000) //2s .into(imageView); 如果渐入渐出的动画效果不满意，可以自定义动画，使用animate()即可，它接受动画的资源id和动画类对象。 12345Glide.with(context) .load(image_url) .animate(R.anim.myAnim) //.animate(new MyAnimation()) .into(imageView); 如果不想使用任何动画，直接将图片显示出来，则使用dontAnimate()方法。 1234Glide.with(context) .load(image_url) .dontAnimate() .into(imageView); 加载Gif动态图加载Gif动态图是Glide的一个亮点，也是将gif动态图的url传入load即可加载，Glide还提供了Gif相关的两个方法：asBitmap()和asGif(); asBitmap()：将gif图的第一帧显示出来 asGif()：严格显示成gif，当传入的Url不是gif的url时，则按错误处理，可以检查load参数是否为gif。 1234Glide.with(context) .load(imageUrl) .asBitmap() .into(imageView); 加载优先级设置图片加载的顺序，有以下几种优先级： Priority.LOW Priority.NORMAL Priority.HIGH Priority.IMMEDIATE 1234Glide.with(context).load(image_url) .priority(Priority.NORMAL) .into(imageView); 加载目标TargetTarget就是Glide获取资源后作用的目标，一般的ImageView就是目标。 12345678910SimpleTarget target = new SimpleTarget&lt;Drawable&gt;()&#123; @Override public void onResourceReady(Drawable resource, GlideAnimation&lt;? super Drawable&gt; glideAnimation) &#123; textView.setBackground(resource); &#125;&#125;; Glide.with(context) .load(image_url) .priority(Priority.NORMAL) .into(target); 这段代码是将TextView作为Target，并将加载到的图片设置为TextView的背景，SimpleTarget接收泛型数据，可以将其更改为其他想要的类型。也可以指定加载的宽度和高度，单位也是px。 缓存策略几种缓存策略： DiskCacheStrategy.ALL：缓存源资源和转换后的资源 DiskCacheStrategy.NONE：什么都不缓存 DiskCacheStrategy.SOURCE：只缓存源资源 DiskCacheStrategy.RESULT：只缓存转换后的资源 1234Glide.with(context) .load(imageUrl) .diskCacheStrategy(DiskCacheStrategy.ALL) .into(imageView); 跳过内存缓存： 1234Glide.with(this) .load(imageUrl) .skipMemory(true) .into(imageView); 缓存的动态清理123Glide.get(this).clearDiskCache(); //清理磁盘缓存，需要在子线程中执行Glide.get(this).clearMemory(); //清理内存缓存，可以在UI线程中执行 结合列表视图的使用Glide在滑动加载图片时表现突出，这也是Glide的优势之一，在项目中很可能是在ListView或者RecyclerView中显示加载的图片： 在使用ListView进行加载时，可以在Adapter的getView中进行使用 12345678910public View getView(int postion,View convertView,ViewGroup parent)&#123; ViewHolder holder; if(convertView == null)&#123; holder = new ViewHolder(); //..... &#125; UserInfo infos = (UserInfo)getItem(postion); String imageUrl = infos.getImageUrl(); Glide.with(convertView.getContext()).load(imageUrl).into(holder.imageView);&#125; 在RecyclerView中使用，在 Adapter的onBindViewHolder方法中使用： 12345public void onBindViewHolder(final MyHolder holder, int position)&#123; Glide.with(holder.imageView.getContext()) .load(args[position]) .into(holder.imageView);&#125; Glide缓存处理进阶可以参考这篇文章：Android图片缓存之Glide进阶 以上就是学习Glide时的知识点整理，后面再接触到新的知识点时再进行补充。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit入门介绍]]></title>
      <url>%2F2016%2F09%2F30%2FRetrofit%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D-1%2F</url>
      <content type="text"><![CDATA[在这次的项目中，由于服务端采用Restful原则提供接口，所以在手机客户端调用接口时，考虑使用现在很流行的Retrofit网络请求框架，很多情况下，和Retrofit搭配使用的是RxJava，他们堪称”黄金组合”，功能强大。还有其他使用率也很高的网络框架，包括google官方提供的一个，关于在项目如何选择，可以参考stormzhang大神写的一篇博客。博客地址为：ANDROID开源项目推荐之「网络请求哪家强」 Restful百度百科：Restful 一种软件架构风格，是一种设计风格而不是标准，只是提供了一组设计原则和约束条件，主要用于客户端和服务器交互的软件或系统。基于这个风格设计的软件可以更加简洁，更有层次，更易于实现缓存等机制。 Retrofit Type-safe HTTP client for Android and Java by SquareRetrofit官网地址:http://square.github.io/retrofit/Retrofit github地址:https://github.com/square/retrofit 创建Retrofit对象在项目中使用需要在模块下面的build.gradle中添加如下依赖： compile ‘com.squareup.retrofit2:retrofit:2.1.0’compile ‘com.squareup.retrofit2:converter-gson:2.1.0’ 如果需要使用RxJava，也需要添加相应的依赖： compile ‘com.squareup.retrofit2:adapter-rxjava:2.1.0’ 创建Retrofit对象需要使用Builder，指定BASR_URL和添加Converter. 1234567891011public class RetrofitClient&#123; public static String Base_url = "http://"+server_addr+":"+port+"VIID-V5/"; public static Retrofit getClient()&#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(Base_url) .addConverterFactory(GsonConverterFactory.create()) .build(); return retrofit; &#125;&#125; server_addr和port：是要请求的服务器地址和端口。在编写请求接口时，是相对base_url而言的。Retrofit2必须要以/结束，不然会抛出非法参数异常。 请求接口定义12345public interface LoginApi&#123; @Headers(&#123;"Contant-Type:application/json","Accept:application/json"&#125;) @POST("login/") Call&lt;TokenBean&gt; login(@Body LoginInfo loginInfo);&#125; 登录发送Post请求，因此接口含有注解@POST，可以看出登录请求的完整地址为http://&quot;+server_addr+&quot;:&quot;+port+&quot;VIID-V5/login，发送POST请求，因此含有请求消息体，为JSON数据格式，可以在android studio安装插件Gson format，将json数据格式转换为实体类。相应也是json数据，也可以转为实体类得到相应数据。 123456789101112131415161718192021222324252627282930313233343536/** 登录请求实体类*/public class LoginInfo&#123; /** username:admin password:admin */ private String username; //当字段与json中的不一致时，可以使用字段@SerializedName @SerializedName("passwd") private String password; public void setUsername(String username)&#123; this.username = username; &#125; public void setPassword(String password)&#123; this.password = password; &#125; //TODO:get() //TODO:toString()&#125;/** 相应实体类：服务端相应一般都会包含错误码和错误信息*/public class TokenBean&#123; private int errCode; private String errMsg; private String access_token; //请求数据的令牌 //TODO:set() //TODO:get() //TODO:toString()&#125; 接口调用12345678910111213141516171819202122232425262728293031323334353637383940public class LoginService&#123; public static LoginApi api; //登陆结果回调 public interface ILoginListener&#123; void loginSuccess(); void loginFailed(String errInfo); &#125; public static void login(LoginInfo info,ILoginListener listener)&#123; api = Retrofit.getClient().create(LoginApi.class); //代理对象 api.login(info).enqueue(new Callback&lt;TokenBean&gt;()&#123; @Override public void onResponse(Call&lt;GitModel&gt; call, Response&lt;GitModel&gt; response) &#123; //服务端响应信息 if(response == null || response.body() == null)&#123; listener.loginFailed("响应消息为空，检查网络连接是否正常!"); return； &#125; if(response.code() == 200 &amp;&amp; response.body().getErrCode() == 0)&#123; //login successful listener.loginSuccess(); //对于其他查询的请求，判断请求成功后，拿到服务端返回的数据 &#125;else if(response.code() == 404)&#123; listener.loginFailed("404: 页面找不到"); &#125;else if(response.code() == 500)&#123; listener.loginFailed("500: 服务器异常"); &#125;else&#123; listener.loginFailed(reponse.code + "：其他异常信息"); &#125; &#125; @Override public void onFailure(Call&lt;GitModel&gt; call, Throwable t) &#123; //服务端响应失败的信息 listener.loginFailed(t.getMessage()); //回调出响应超时信息 &#125; &#125;); &#125; &#125; &#125; 一般的Retrofit使用就是这样的流程，在大型项目中，可以根据项目需要，进行自定义。 Retrofit注解详情请求方法 请求方法 方法简单描述 POST post请求，信息包含在请求体RequestBody中，一般用于添加 GET get请求方式，参数包含在Url ，一般用于查询 DELETE 删除数据 PUT 修改数据 PATCH HEAD OPTIONS HTTP @HTTP(method=”get”,path=”login/“,hasBody=true) 标记 标记 简单描述 表单请求 FormUrlEncoded 表示请求体是一个form表单，Content-Type:application/x-www-form-urlencoded 表单请求 Multipart 请求体是一个支持文件上传的form表单，Content-Type:multipart/form-data Streaming 表示响应体的数据用流的形式返回，如果没有使用该注解，默认会把数据全部载入内存，之后通过流获取数据也不过是读取内存中的数据，所以如果返回的数据比较大，就需要使用这个注解 参数注解 位置 参数注解 描述 作用于方法 Headers 用于添加请求头 作用于方法参数 Header 用于添加不固定值得Header，也用于鉴权的目的 作用于方法参数 Body 用于非表单请求体 作用于方法参数 Field/FieldMap 用于表单字段，与FormUrlEncoded配合使用 作用于方法参数 Part/PartMap 用于表单字段，与Multipart配合使用，用于有文件上传的情况，PartMap的接受类型是Map，非String会调用toString() 作用于方法参数 Path 用于URL，参数是URL的一部分 作用于方法参数 Query/QueryMap 用于URL，比如：@Query(“id”)，http://127.0.0.1:8080/users/id=10 作用于方法参数 Url 完整的URL {占位符}和Path尽量只用在URL的path部分，url中的参数用Query和QueryMap代替 Query/Field和Part这三者都支持数组和实现了Iterable接口的类型，比如List/Set。 添加head信息，动态添加和静态添加 123456Call&lt;String&gt; getData(@Query("item[]") List&lt;Integer&gt; item); // ----------------------------------- @GET("user")Call&lt;User&gt; getUser(@Header("Authorization") String authorization) @Headers("Cahce-Control:max-age=640000") 数据类型转换器Retrofit支持的数据类型转换器 Gson: com.squareup.retrofit2:converter-gson:2.1.0 Jackson: com.squareup.retrofit2:converter-jackson:2.1.0 Moshi: com.squareup.retrofit2:converter-moshi:2.1.0 Protobuf: com.squareup.retrofit2:converter-protobuf:2.1.0 Wire: com.squareup.retrofit2:converter-wire:2.1.0 Simple XML: com.squareup.retrofit2:converter-simplexml:2.1.0 Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars:2.1.0 Retrofit提供的CallAdapter： name build.gradle中的依赖 rxjava com.squareup.retrofit2:adapter-rxjava:2.1.0 java8 com.squareup.retrofit2:adapter-java8:2.1.0 guava com.squareup.retrofit2:adapter-guava:2.1.0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo start]]></title>
      <url>%2F2016%2F09%2F28%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
